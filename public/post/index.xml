<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on David Nix&#39;s Blog - Tutorials, Opinions, Rants</title>
    <link>https://davidnix.io/post/</link>
    <description>Recent content in Posts on David Nix&#39;s Blog - Tutorials, Opinions, Rants</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Nov 2015 07:27:48 -0700</lastBuildDate>
    <atom:link href="https://davidnix.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building Modern Web Apps in Go Part 2</title>
      <link>https://davidnix.io/post/building-modern-web-apps-in-go-part-2/</link>
      <pubDate>Thu, 19 Nov 2015 07:27:48 -0700</pubDate>
      
      <guid>https://davidnix.io/post/building-modern-web-apps-in-go-part-2/</guid>
      <description>&lt;p&gt;This was a presentation I gave at the Denver Go Meetup in November 2015.&lt;/p&gt;

&lt;p&gt;My goal is to teach others and myself how to build a robust, modern web application in Go. My hope is that startups will turn to Go instead of Rails or Django when building web apps.&lt;/p&gt;

&lt;p&gt;What is a “modern web app”?  It’s a server that does all this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Routing&lt;/li&gt;
&lt;li&gt;Middleware&lt;/li&gt;
&lt;li&gt;Request Scoped Data&lt;/li&gt;
&lt;li&gt;User Authentication&lt;/li&gt;
&lt;li&gt;Interfaces with a database&lt;/li&gt;
&lt;li&gt;Compiles js, csss, images and other assets&lt;/li&gt;
&lt;li&gt;Renders templates and views&lt;/li&gt;
&lt;li&gt;Serves static files&lt;/li&gt;
&lt;li&gt;Shuts down gracefully&lt;/li&gt;
&lt;li&gt;Sends transactional email&lt;/li&gt;
&lt;li&gt;Live reloading&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt;  This is an exploration. I am not an expert on the subject. I’ve built microservices in Go but have yet to build a monolith similar to Rails or Django.&lt;/p&gt;

&lt;p&gt;This is the first in a multi-part series.  How many parts?  I’m not sure yet.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://davidnix.io/post/building-modern-web-apps-in-go-part-1&#34;&gt;Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Part 2 (you’re reading it)&lt;/p&gt;

&lt;p&gt;I welcome any feedback or criticism.&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34;
data-id=&#34;fbc89f873cb8493998f341c8dc0c16d6&#34; data-ratio=&#34;1.77777777777778&#34;
src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Go&#39;s Error Handling is Elegant</title>
      <link>https://davidnix.io/post/error-handling-in-go/</link>
      <pubDate>Tue, 10 Nov 2015 21:47:04 -0700</pubDate>
      
      <guid>https://davidnix.io/post/error-handling-in-go/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;m writing in response to &lt;a href=&#34;http://spaces-vs-tabs.com/4-weeks-of-golang-the-good-the-bad-and-the-ugly/&#34;&gt;this
article&lt;/a&gt;.
Specifically, the section titled &amp;ldquo;The Ugly&amp;rdquo; featuring error handling.&lt;/p&gt;

&lt;p&gt;New programmers to Go often critique Go&amp;rsquo;s error handling.  Notice I didn&amp;rsquo;t say
&lt;em&gt;exception&lt;/em&gt; handling.  Go doesn&amp;rsquo;t have exceptions, although you can sort of
emulate it with &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;panic and
recover&lt;/a&gt;.  But I highly
recommend against it.  It&amp;rsquo;s an anti-pattern if used too often.  Go has a
simpler way of handling when something goes wrong in your program.&lt;/p&gt;

&lt;p&gt;The Go authors put a lot of thought into error handling.  I feel they came up
with one of the better solutions out there.  It&amp;rsquo;s simple and elegant.&lt;/p&gt;

&lt;p&gt;As a refresher, Go allows multiple return values.  By convention, if something
can go wrong, a function returns an error as its last return value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ETPhoneHome(msg string) (string, error) {
    // implementation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An &lt;code&gt;error&lt;/code&gt; type is just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means &lt;strong&gt;any&lt;/strong&gt; type that implements a method called &lt;code&gt;Error()&lt;/code&gt; returning a
&lt;code&gt;string&lt;/code&gt; satisfies the &lt;code&gt;error&lt;/code&gt; interface. The string returned should describe
what went wrong. Check out Go&amp;rsquo;s
&lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces&#34;&gt;interfaces&lt;/a&gt; if you&amp;rsquo;re
confused.&lt;/p&gt;

&lt;p&gt;In a lot of sample Go code, you see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;response, err := ETPhoneHome(&amp;quot;I can&#39;t fly this bike forever!&amp;quot;)
if err != nil {
    // handle the error, often:
    return err
}
// do something with response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of programmers have beef with this seemingly constant nil checking:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {
    // handle the error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take a break from Go and compare it to other languages.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s &lt;del&gt;ye olde&lt;/del&gt; classic Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Java
try {
    String response = ET.phoneHome(&amp;quot;I hate white lab coats.&amp;quot;)
    System.out.println(response);
} catch(Exception e) {
    System.out.println(&amp;quot;Exception thrown  :&amp;quot; + e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or shiny new Swift 2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift
// Option 1
do {
    let response = try ETPhoneHome(&amp;quot;Those are guns not walkie talkies!&amp;quot;)
    // process response
} catch (let error as NSError) {
    print(&amp;quot;oops&amp;quot;, error)
}

// Option 2: assign to an optional variable
let response = try? ETPhoneHome(&amp;quot;Halp!&amp;quot;)

// Option 3: crash the app if an error is thrown
let response = try! ETPhoneHome(&amp;quot;BOOM&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So which is simpler? &lt;code&gt;Do, try, catch&lt;/code&gt; and friends?  Choosing among several
error catching options?  Or just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Go
if err != nil {
    // handle the error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you could argue, only one caller needs the try/catch dance.  Anything
downstream could throw exceptions all the live long day. In practice, that&amp;rsquo;s
rarely the case.  With Swift, I find myself deciding between &lt;code&gt;do/catch&lt;/code&gt; or
&lt;code&gt;try?&lt;/code&gt; quite often, especially in unit tests.&lt;/p&gt;

&lt;p&gt;Interpreted languages, like Ruby, are more concise because you aren&amp;rsquo;t required
to handle exceptions at all.  Swift and Java won&amp;rsquo;t compile until you force the
caller to handle the exception.  Go won&amp;rsquo;t compile unless the caller handles or
ignores the error value.&lt;/p&gt;

&lt;p&gt;With Ruby, you just have to &lt;em&gt;know&lt;/em&gt; that a method might raise an exception.
Rails uses a bang in the method name (ex: &lt;code&gt;model.save!&lt;/code&gt;) to show that some sort
of exception may be raised.  But otherwise, good luck trying to find when,
where, or what. Therefore, it&amp;rsquo;s more common in interpreted languages to see
exceptions at runtime. Go (along with Swift and Java) try to tell you about all
error cases up front to limit unexpected behavior at runtime.&lt;/p&gt;

&lt;p&gt;The Go authors argue that not all exceptions are exceptional.  Not all errors
should crash your app. I agree.  If you can gracefully recover from an error,
you should do so.  Your app will be stable and robust.  Of course, easier said
than done.  It takes more effort on the programmer&amp;rsquo;s part. In Ruby you can
pinky swear an exception will never happen and move on. That is, until a
customer calls you complaining about your app not working.&lt;/p&gt;

&lt;h2 id=&#34;errors-are-values:6459a39e6d3fb0d6cf471ef567c5fb46&#34;&gt;Errors are Values&lt;/h2&gt;

&lt;p&gt;The Go team purposefully chose errors to be values.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Values can be programmed, and since errors are values, errors can be programmed.
Errors are not like exceptions.  There&amp;rsquo;s nothing special about them, whereas an
unhandled exception can crash your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The above is from &lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;https://blog.golang.org/errors-are-values&lt;/a&gt; by Rob Pike. Do
yourself a huge favor and read Pike&amp;rsquo;s blog post next.&lt;/p&gt;

&lt;p&gt;In Go, functions pass errors around just like any other type.  Because indeed
they are just a type.&lt;/p&gt;

&lt;p&gt;Exceptions, on the other hand, are unique.  They can wreak havoc on your
program if left unchecked.  (I realize there are technical differences between
Swift errors and exceptions. But the semantics are the same in regards to error
handling.)&lt;/p&gt;

&lt;p&gt;So, if we can handle errors using simple values, why do we need this special
exception stuff?  Why not leave that complexity out of the language?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not sure if the Go authors reached that exact conclusion, but it make sense
to me.&lt;/p&gt;

&lt;h2 id=&#34;flow-of-control:6459a39e6d3fb0d6cf471ef567c5fb46&#34;&gt;Flow of Control&lt;/h2&gt;

&lt;p&gt;Rob Pike also writes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Error handling [in Go] does not obscure the flow of control.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because an &lt;code&gt;error&lt;/code&gt; in Go must either be 1) handled/ignored right then and there
or 2) returned to the caller, you can track the path of the &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The flow of control is less clear in other languages.  Take Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift
do {
    // If successful, the happy path is now nested.
} catch (let error as NSError) {
    // handle error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For simple things, it&amp;rsquo;s okay to have that nesting.  But what if there&amp;rsquo;s
additional nesting like &lt;code&gt;if/else&lt;/code&gt;? It could quickly become hard to read.&lt;/p&gt;

&lt;p&gt;Whereas in Go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Go
result, err := SomeFunction()
if err != nil {
    // handle the error
}
// happy path proceeds as normal without nesting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift 2 introduced the &lt;code&gt;guard&lt;/code&gt; statement to improve flow of control. But you
can only use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift
guard let result = try? SomeFunction() else {
    return
}
// result is in scope, proceed with happy path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can&amp;rsquo;t inspect the error using a Swift &lt;code&gt;guard&lt;/code&gt;. But what if you want to
inspect the error AND avoid the nesting?  You can do this in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift
var result: Any?
do {
    result = SomeFunction()
} catch (let error as NSError) {
    // handle error
}
// proceed with happy path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So how is the above cleaner than the below?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Go
result, err := SomeFunction()
if err != nil {
    // handle the error
}
// trot down the happy path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Ruby, raising and catching an exception acts like the dreaded &lt;code&gt;GOTO&lt;/code&gt;
statement. Ruby code that raises an exception can be arbitrarily deep. The
caller that rescues the exception can be anywhere up the stack. So, rescuing
the exception is like saying &amp;ldquo;GOTO this random place up the stack&amp;rdquo;.  That&amp;rsquo;s
terrible flow of control. I&amp;rsquo;ve spent my fair share of time debugging Ruby code
with errant exceptions.  It&amp;rsquo;s no fun at all and hard to trace.&lt;/p&gt;

&lt;h2 id=&#34;code-your-way-out-of-it:6459a39e6d3fb0d6cf471ef567c5fb46&#34;&gt;Code Your Way Out of It&lt;/h2&gt;

&lt;p&gt;Just because you can do this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {
    // handle the error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doesn&amp;rsquo;t mean you have to litter it everywhere in your code.  You&amp;rsquo;re free to
code your way out of it. Delegate error handling to a function or an object.
You&amp;rsquo;re a programmer after all.  Write an abstraction!&lt;/p&gt;

&lt;p&gt;As a simple example, when I write CLI tools in Go, I usually have a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func checkErr(err error) {
    if err != nil {
        fmt.Println(&amp;quot;ERROR:&amp;quot;, err)
        os.Exit(1)
    }
}

// Or as a kind user on reddit refactored:
func checkErr(err error) {
    if err != nil {
        log.Fatal(&amp;quot;ERROR:&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a CLI tool, this works fine.  But, um, don&amp;rsquo;t do that in a web server.&lt;/p&gt;

&lt;p&gt;Rob Pike admits helper functions don&amp;rsquo;t always do the trick.  Again, read
&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;https://blog.golang.org/errors-are-values&lt;/a&gt; for a great example of Pike coding
his way out of messy error handling.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:6459a39e6d3fb0d6cf471ef567c5fb46&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope I&amp;rsquo;ve shown Go&amp;rsquo;s error handling isn&amp;rsquo;t that bad. I even deem it elegant. I
think a lot of programmers new to Go get frustrated because several functions
in the standard library return errors. That means you have to handle them.
Which in turn means you have to spend effort on them. Which in turn means
you&amp;rsquo;re writing rock solid, stable software. That&amp;rsquo;s not a bad deal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Modern Web Apps in Go Part 1</title>
      <link>https://davidnix.io/post/building-modern-web-apps-in-go-part-1/</link>
      <pubDate>Thu, 24 Sep 2015 06:59:45 -0700</pubDate>
      
      <guid>https://davidnix.io/post/building-modern-web-apps-in-go-part-1/</guid>
      <description>&lt;p&gt;This was a presentation I gave at the Denver Go Meetup in September 2015.&lt;/p&gt;

&lt;p&gt;My goal is to teach others and myself how to build a robust, modern web application in Go. My hope is that startups will turn to Go instead of Rails or Django when building web apps.&lt;/p&gt;

&lt;p&gt;What is a “modern web app”?  It’s a server that does all this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Routing&lt;/li&gt;
&lt;li&gt;Middleware&lt;/li&gt;
&lt;li&gt;Request Scoped Data&lt;/li&gt;
&lt;li&gt;User Authentication&lt;/li&gt;
&lt;li&gt;Interfaces with a database&lt;/li&gt;
&lt;li&gt;Compiles js, csss, images and other assets&lt;/li&gt;
&lt;li&gt;Renders templates and views&lt;/li&gt;
&lt;li&gt;Serves static files&lt;/li&gt;
&lt;li&gt;Shuts down gracefully&lt;/li&gt;
&lt;li&gt;Sends transactional email&lt;/li&gt;
&lt;li&gt;Live reloading&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt;  This is an exploration. I am not an expert on the subject. I’ve built microservices in Go but have yet to build a monolith similar to Rails or Django.&lt;/p&gt;

&lt;p&gt;This is the first in a multi-part series.  How many parts?  I’m not sure yet.&lt;/p&gt;

&lt;p&gt;Part 1 (you’re reading it)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://davidnix.io/post/building-modern-web-apps-in-go-part-2&#34;&gt;Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt;  I make fun of Rails a LOT.  On purpose.  If you’re BFFs with DHH, consider yourself warned.&lt;/p&gt;

&lt;p&gt;I welcome any feedback or criticism.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/DavidNix/modern-web-apps-in-go&#34;&gt;View the sample code here.&lt;/a&gt;&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34;
data-id=&#34;91a1a570e652473f8247b7668c4ebaa5&#34; data-ratio=&#34;1.77777777777778&#34;
src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>